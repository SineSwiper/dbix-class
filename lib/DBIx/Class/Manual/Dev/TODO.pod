package DBIx::Class::Manual::Dev::TODO;

=head1 NAME

DBIx::Class::Manual::Dev::TODO - TODO list of S through XXL tasks for eager
young minds

=head1 DESCRIPTION

This document attempts to centralize the collective knowledge about various
L<DBIx::Class> C<TODO> tasks, ranging from sketches of mundane bugfixes to
minutes of heated design discussions.

If you are just curious - L<jump straight to the "small" LIST OF OUTSTANDING
TASKS|/TODOs>. If, however, you plan to edit this document, please read the
L</HOW TO EDIT THIS DOCUMENT> section first, as parts of this POD double as
B<machine parseable> L<metadata|/Metadata>.

=head2 Note for GitHub Users

If you are visiting the DBIx-Class project on GitHub you may be surprised to
find this unorthodox "README". What you are seeing is GitHb rendering a
symlink pointing to the latest revision of
L<DBIx::Class::Manual::Dev::TODO> in the currently selected git branch
(normally C<master>). Fork this, hack away, and send us a pull request :)

=head1 HOW TO EDIT THIS DOCUMENT

Anyone (developer or not) is welcome and encouraged to extend and/or change
this document. No idea is too small or too big, even a standalone C<=head3>
is appreciated as it can serve as a seed for further discussion/writeup. The
idea is to have a wiki-like process without the headaches of maintaining an
actual wiki, and more importantly having the contents of said "wiki" always
usable offline. If you are adding/modifying entries in this document, please
try to follow the style of already existing TODOs. Also fill in as much
information as possible, and don't hesitate to be overly technical - after
all this document is intended for developers, and is expected to be quite
large and in places quite complex. More info is always better than less.

No attempt is made to sort individual tasks in each TODO section, though
ideas on how to do this for better readability are more than welcome.

=head2 Branching and subsequent merging

The C<TODO> POD section of the C<master> branch contains a commented-out
C<=head2> titled I<Branch-local TODO> (it is the first C<=head2> following
the L</TODOs> C<=head1>). When a branch is made, authors and/or reviewers
should uncomment this heading and add notes on what work is still necessary
before merging back to mainline. It is possible that after a merge the
heading will not be reverted to its original form, however there is a
sanity-check implemented by F<maint/dbic_todo> (and invoked bu the C<make
dist> target) that will catch this to prevent CPAN dissemination (perhaps
this particular bit warrants a git pre-commit hook protecting master?)

=head2 Metadata

To stay in the perl-mandated laziness framework, this document doubles as a
holder of metadata on the significance of individual issues. The
F<maint/dbic_todo> script executed as part of C<make dist> will stop the
dist-building process if it detects any unresolved issues as indicated
below.

Flags for each C<=headX> paragraph are declared as individual elements
within an C<=over> / C<=back> block immediately following the C<=headX>. No
POD markup is permitted for the flag-lines (no intermediate C<=item>
elements). However each line is still separate by double-space (C<\n\n>) as
required by the POD specification.

The flags are simple key/value pairs with C<:> separating each key from its
value. Both the value and the separator C<:> are optional. If a flag value is
not supplied it's value will be an empty list. Each flag has a short name in
addition to its canonical one. All flags supplied have their values aggregated
in an arrayref. Flags always aggregate their values in an arrayref, even if
there is only one value supplied. See the known flag list on top of
F<maint/dbic_todo> for details.

To put it in perl-speek flags for each TODO item are parsed by:

  my %flags;
  while (my ($todo_name, $raw_flags) = $todo_pod_contents =~ /
    /g
  ) {
  }

=head3 List of metadata flags

Each flag has a short name in addition to its canonical one. Currently
recognized flags are:

=over

=item * Blocker (BL)

This is the most important flag. The value is the version at which the
blocker goes in effect (or any version if no value is supplied). The version
is specified as a perl decimal only - e.g. C<0.08200>, without leading C<v> or
other characters. The distmaker aborts the creation of a tarball if a
blocker is found for the version being currently packaged. The idea is to
make it dead easy to answer the annoying question "Is master ready to
release?".

=item * Regression (RG)

Indicates the issue is a known regression. Optionally indicates in which
version the regression was first introduced. It is always preferred to
have no known regressions, but in the real world drinking beer trumps chasing
bugs, so some known regressions may remain unfixed for some (extended period
of) time.

=item * Depends (DEP)

The fix for this issue depends on something else. You can use
C<LE<lt>/[relevant issue head3 title]E<gt>> constructs to link to the proper
issue if it is listed in this document.

=item * RT_Entry (RT)

The described TODO is a result of (or is independently described by) the RT
ticket with the specified number. This flag serves only as a reminder for
the maintainers to close the corresponding tickets when the issue is
resolved.

=item * Needs_Specification (NS)

Indicates that this is just a floating idea that still needs an actual
specification. Ideally such specification comes in the form of a branch,
containing a set of failing tests indicating what things should eventually
look like.

=item * Request_For_Comments (RFC)

Indicates the presence of a proof of concept (ideally some code with a
passing/failing test demonstrating intended behavior), for which the
original author is soliciting discussion from other developers before
delving into cleaning this idea up for eventual merging.

=item * Signed_Off (SIG)

Indicates which core developers have signed-off on a particular idea/plan

=item * ...

If a (sensible) need arises for more flags - just add them :) Note that you
will need to adjust the flag list in F<maint/dbic_todo> as well.

=back

It is important to note that this is a novel experiment in POD semantic
overloading abuse, and as such the declaration, format and meaning of
individual flags can and probably will be changed down the road. However,
if this is to happen the body of text existing at the time will be
properly recoded into the newly agreed upon style, and this instruction
section will be updated as well.

=head1 TODOs

=for comment WHEN IN A BRANCH USE THIS =head2 TO INDICATE MERGE REQUIREMENTS
=head2 Branch-local TODOs
Delete the C<=for comment> line above, and replace this text with C<=head3>
paragraphs detailing the reasons for this branch to exist.

=head2 Extensions / New Features

=head3 DateTime Manipulation DSL

=over

DEP:L</-op and -func SQLA operators>

DEP:L</Blead/Maint separation>

=back

Very sound design, tested on/supports enough databases to be releaseable.
Currently contains some nasty hacks (e.g. inclusion of a C<$storage> object
reference in the C<$sql_maker> object), but the API is solid and doesn't
contain obvious WTFs. Unfortunately it very heavily relies on the C<-op>
functionality which does suffer from multiple inconsistencies, which make it
unfit for a general release (see the linked C<DEP>). We could potentially
release this as a part of the C<blead> cycle without addressing the other
issues, however an official release can not happen before the ambiguity of
the fundamentals is resolved.

=head3 -op and -func SQLA operators

=over

NS

DEP:L</Data::Query migration>

=back

These are currently present in several forms in both the SQLA and the DBIC
trees (neither of the branches has been merged yet). Frew is the author of
pretty much all of this, and was supposed to clean things up leaving only
one branch in the SQLA repo.

The actual obstacle to merging this is the ambiguity of what happens on
bindtype information clashes, and how does the bindtype propagate further
down the callstack in case the C<-op/-func> are not the only thing in a RHS
chain. So far it seems that Data::Query's architecture is capable of
sidestepping this issue entirely, but nobody has investigated this yet.

=head3 Data::Query migration

Thanks to mst Data::Query is now much closer to reality than it may seem. In
fact it fully passes the entire original SQLA test suite and is ready for an
attempt of porting DBIC to the new architecture.

The only really burning outstanding issue is how to encode the concept of
"dialect" in an instance of D::Q. The approach attempted by Frew in the
L</DateTime_Manipulation_DSL> branch turns out way too ugly and entangled.

=head3 Join Arguments

join-pref merger cleanup

=head3 Dynamic storage flag specification

=head3 UNION-ized M+N prefetch

Once we can assemble out-of-order has_many prefetches, it should become
trivial to parse back the result of something like:

  SELECT ....

=head3 Proper multiupdate

=head2 Warts / Cleanups / Deprecations

=head3 Switch DBIx::Class::Admin and the dbicadmin utility to Moo

Moose is slow. *Really* slow for CLI. We can do better.

=head3 Replicated cleanup and Moo migration

=head3 Nested from rs-attribute

=over

RG:0.08115

BL:0.08200

=back

The ability to nest sources in {from} was lost somewhere around 0.08115. The
goal is to be able to express things like

 FROM foo LEFT JOIN ( bar JOIN baz ON bar-baz_cond ) ON foo-(bar/baz)_cond

This kind of construct was apparently popular at one point, as it is seen a
lot in the wild, 

do backwards comp of Old style nested from, blocks 0.08200, only backcompat, no futher
dev. Will be supplanted by joinargs-like nest specs (probably even with
-nest for name or something)

=head3 prefetch/inflate 

=head2 replicated multidb

=head2 pg_cursors

=head2 prepare cached flag

=head2 select/group_by/order_by clarify semantics

=head2 subqueried prefetch without double where

=head2 group_by fix

=head2 remove try-tiny

=head2 async / poe / easydbi

=head2 txn_do opts/ dbh_do

=head2 storage Moo + Roles

=head2 find_or_create claify (RT)

=head2 sql-side ident-filter

=head2 subq realias

=head2 jifty dbi

=head2 DBD::CSV

=head2 schema-diff

=head2 enable_utf8

=head2 resultset lazy role composition

=head2 prettyprint
